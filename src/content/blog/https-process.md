---
title: 'https process analysis'
description: 'https的tls解析'
pubDate: 'Jul 31 2025'
heroImage: '../../assets/blog-placeholder-5.jpg'
---

#### https建立的整个过程

</br>

<style>
    .p1 {
    font-size: 16px !important;  /* 强制覆盖默认大小 */
    line-height: 1.4 !important; /* 调整行高，让排版更紧凑 */
  }
</style>

##### 1.第一阶段：基础设施准备与 TCP 连接

<div class="p1">
在加密还没开始之前，浏览器需要先找到服务器并建立基础的通信管道。</br>
1.DNS 解析：浏览器将域名（如 www.google.com）转换为 IP 地址。</br>
2.TCP 三次握手:</br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 浏览器向服务器发送 SYN 包。</br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 服务器回复 SYN+ACK 包。</br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 浏览器回复 ACK 包。</br>
结果：建立了可靠的传输通道，但此时传输的数据都是明文。
</div>
</br>

##### 第二阶段：TLS/SSL 握手（核心阶段）

<div class="p1">

```html
在加密还没开始之前，浏览器需要先找到服务器并建立基础的通信管道。 
1.Client Hello（浏览器发起）：
     浏览器告诉服务器：我支持哪些加密套件（Cipher Suite）、TLS 版本，并发送一个随机数 A (Client Random) 
2.Server
     Hello（服务器回应）： 服务器确认加密套件，发送由 CA 签发的数字证书（包含服务器的公钥），并发送另一个
     随机数 B (ServerRandom)。 
3.验证证书（浏览器验证）： 
     * 浏览器拿到证书后，会去验证证书的合法性（是否过期、是否由受信任的 CA机构签发、域名是否匹配）。 
     * 关键点 - 非对称加密用途 1：身份验证】：验证证书签名的过程使用了非对称算法（利用 CA根证书的公钥解密签名，对比哈希值）。 
4.密钥交换（Key Exchange）：
     这是最关键的一步，目的是生成后续通信用的“会话密钥（Pre-master secret / Session Key）”。 
    【关键点 - 非对称加密用途2：密钥协商】： 
     传统 RSA 算法：浏览器生成一个随机数 C (Pre-master secret)，使用证书里的服务器公钥进行加密，然后发给服务器。服务器用
     自己的私钥解密，拿到随机数 C。 
     现代 DH/ECDHE 算法：双方交换 Diffie-Hellman参数。服务器会用私钥对参数进行签名（防篡改）， 浏览器用公钥验证签名。随后
     双方利用算法在本地生成相同的 Pre-mastersecret，而无需直接在网络上传输这个密钥。 
5.生成会话密钥：
    a. 此时，浏览器和服务器都拥有了三个要素：随机数 A、随机数 B、随机数 C (Pre-master secret)。
    b. 双方使用相同的算法，利用这三个数生成最终的对称密钥（Session Key）。
6.Finished：
    双方发送“Finished”消息，表示握手结束，且后续发送的消息都将使用刚才生成的对称密钥进行加密。
```

</div>

当我们在浏览器地址栏看到那把“小锁”时，背后发生了一系列严密的身份验证逻辑。在 TLS 握手的第二阶段，浏览器拿到服务器发来的证书后，并不会无条件信任，而是必须经过以下四个核心步骤的“政审”。

##### 第一步：验证数字签名（完整性与来源）

这是利用**非对称加密**验证证书真伪的核心环节。浏览器需要确认：证书内容是否被篡改？是否真的是由声明的 CA 机构签发的？

验证逻辑如下：

1.  **计算摘要**：浏览器读取证书的“明文信息”（包含域名、有效期、公钥等），使用指定的哈希算法（如 SHA-256）计算出 **Hash A**。
2.  **解密签名**：浏览器找到颁发该证书的上级 CA 机构，提取其**公钥**。用这个公钥解密证书里的“数字签名”，得到 **Hash B**。
3.  **比对结果**：
    *   若 `Hash A == Hash B`：证明证书未被篡改，且确实由该 CA 签发。
    *   若 `Hash A != Hash B`：验证失败，浏览器报警。

> **核心原理**：只有拥有 CA 私钥的机构才能生成可以通过 CA 公钥解密的签名。

##### 第二步：验证信任链 (Chain of Trust)

单张证书验证通过还不够，浏览器通过“顺藤摸瓜”的方式来建立完整的信任链条。

1.  **层层向上**：浏览器验证了服务器证书（Leaf Certificate）后，会查看其颁发者（Issuer）。
2.  **中间证书**：如果颁发者是中间 CA，浏览器会继续寻找验证中间 CA 的证书，直到找到**根证书（Root Certificate）**。
3.  **终极信任**：到达根证书时，浏览器（或操作系统）会检查本地内置的 **“受信任根证书列表” (Root Store)**。
    *   如果该根证书在系统的“白名单”里，信任链闭环，验证通过。
    *   如果链条中断或根证书不可信，浏览器提示“您的连接不是私密连接”。

##### 第三步：对称加密的内容校验

虽然原理是“同一个密钥”，但在现代 TLS（特别是 TLS 1.3）的实际工程实现中，为了防止重放攻击和提高安全性，双方会基于那个协商
好的“主密钥（Master Secret）”推导出两把**独立的对称密钥**：
1.  **Client Write Key（客户端写入密钥）：**
      客户端用来加密发给服务器的数据。
      服务器持有这把钥匙，用来解密客户端发来的数据。
2.  **Server Write Key（客户端写入密钥）：**
      服务器用来加密发给客户端的数据。
      客户端持有这把钥匙，用来解密服务器发来的数据。
    



